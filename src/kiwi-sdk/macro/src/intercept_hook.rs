// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
pub type Context = kiwi::kiwi::intercept_types::Context;
pub type Action = kiwi::kiwi::intercept_types::Action;
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "intercept"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_intercept(arg0: i32,) -> i32 {
    #[allow(unused_imports)]
    use ::kiwi_sdk::wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    ::kiwi_sdk::wit_bindgen::rt::run_ctors_once();
    
    let l0 = i32::from(*((arg0 + 0) as *const u8));
    let l4 = i32::from(*((arg0 + 12) as *const u8));
    use kiwi::kiwi::intercept_types::ConnectionCtx as V9;
    let v9 = match l4 {
      n => {
        debug_assert_eq!(n, 0, "invalid enum discriminant");
        let e9 = {
          let l5 = i32::from(*((arg0 + 16) as *const u8));
          
          kiwi::kiwi::intercept_types::Websocket{
            addr: match l5 {
              0 => None,
              1 => {
                let e = {
                  let l6 = *((arg0 + 20) as *const i32);
                  let l7 = *((arg0 + 24) as *const i32);
                  let len8 = l7 as usize;
                  let bytes8 = Vec::from_raw_parts(l6 as *mut _, len8, len8);
                  
                  ::kiwi_sdk::wit_bindgen::rt::string_lift(bytes8)
                };
                Some(e)
              }
              _ => ::kiwi_sdk::wit_bindgen::rt::invalid_enum_discriminant(),
            },
          }
        };
        V9::Websocket(e9)
      }
    };
    let l10 = i32::from(*((arg0 + 32) as *const u8));
    use kiwi::kiwi::intercept_types::EventCtx as V26;
    let v26 = match l10 {
      0 => {
        let e26 = {
          let l11 = i32::from(*((arg0 + 40) as *const u8));
          let l15 = *((arg0 + 52) as *const i32);
          let l16 = *((arg0 + 56) as *const i32);
          let len17 = l16 as usize;
          let bytes17 = Vec::from_raw_parts(l15 as *mut _, len17, len17);
          let l18 = i32::from(*((arg0 + 64) as *const u8));
          let l20 = *((arg0 + 80) as *const i32);
          let l21 = *((arg0 + 88) as *const i64);
          
          kiwi::kiwi::intercept_types::KafkaEventCtx{
            payload: match l11 {
              0 => None,
              1 => {
                let e = {
                  let l12 = *((arg0 + 44) as *const i32);
                  let l13 = *((arg0 + 48) as *const i32);
                  let len14 = l13 as usize;
                  
                  Vec::from_raw_parts(l12 as *mut _, len14, len14)
                };
                Some(e)
              }
              _ => ::kiwi_sdk::wit_bindgen::rt::invalid_enum_discriminant(),
            },
            topic: ::kiwi_sdk::wit_bindgen::rt::string_lift(bytes17),
            timestamp: match l18 {
              0 => None,
              1 => {
                let e = {
                  let l19 = *((arg0 + 72) as *const i64);
                  
                  l19 as u64
                };
                Some(e)
              }
              _ => ::kiwi_sdk::wit_bindgen::rt::invalid_enum_discriminant(),
            },
            partition: l20 as u32,
            offset: l21 as u64,
          }
        };
        V26::Kafka(e26)
      }
      n => {
        debug_assert_eq!(n, 1, "invalid enum discriminant");
        let e26 = {
          let l22 = *((arg0 + 40) as *const i32);
          let l23 = *((arg0 + 44) as *const i32);
          let len24 = l23 as usize;
          let bytes24 = Vec::from_raw_parts(l22 as *mut _, len24, len24);
          let l25 = *((arg0 + 48) as *const i64);
          
          kiwi::kiwi::intercept_types::CounterEventCtx{
            source_id: ::kiwi_sdk::wit_bindgen::rt::string_lift(bytes24),
            count: l25 as u64,
          }
        };
        V26::Counter(e26)
      }
    };
    let result27 = <_GuestImpl as Guest>::intercept(kiwi::kiwi::intercept_types::Context{
      auth: match l0 {
        0 => None,
        1 => {
          let e = {
            let l1 = *((arg0 + 4) as *const i32);
            let l2 = *((arg0 + 8) as *const i32);
            let len3 = l2 as usize;
            
            Vec::from_raw_parts(l1 as *mut _, len3, len3)
          };
          Some(e)
        }
        _ => ::kiwi_sdk::wit_bindgen::rt::invalid_enum_discriminant(),
      },
      connection: v9,
      event: v26,
    });
    ::kiwi_sdk::wit_bindgen::rt::dealloc(arg0, 96, 8);
    let ptr28 = _RET_AREA.0.as_mut_ptr() as i32;
    use kiwi::kiwi::intercept_types::Action as V30;
    match result27 {
      V30::Forward=> {
        {
          *((ptr28 + 0) as *mut u8) = (0i32) as u8;
        }
      }
      V30::Discard=> {
        {
          *((ptr28 + 0) as *mut u8) = (1i32) as u8;
        }
      }
      V30::Transform(e) => {
        *((ptr28 + 0) as *mut u8) = (2i32) as u8;
        match e {
          Some(e) => {
            *((ptr28 + 4) as *mut u8) = (1i32) as u8;
            let vec29 = (e).into_boxed_slice();
            let ptr29 = vec29.as_ptr() as i32;
            let len29 = vec29.len() as i32;
            ::core::mem::forget(vec29);
            *((ptr28 + 12) as *mut i32) = len29;
            *((ptr28 + 8) as *mut i32) = ptr29;
          },
          None => {
            {
              *((ptr28 + 4) as *mut u8) = (0i32) as u8;
            }
          },
        };},
      }
      ptr28
    }
    
    const _: () = {
      #[doc(hidden)]
      #[export_name = "cabi_post_intercept"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn __post_return_intercept(arg0: i32,) {
        let l0 = i32::from(*((arg0 + 0) as *const u8));
        match l0 {
          0 => (),
          1 => (),
          _ => {
            let l1 = i32::from(*((arg0 + 4) as *const u8));
            match l1 {
              0 => (),
              _ => {
                let l2 = *((arg0 + 8) as *const i32);
                let l3 = *((arg0 + 12) as *const i32);
                let base4 = l2;
                let len4 = l3;
                ::kiwi_sdk::wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
              },
            }
          },
        }
      }
    };
  };
  use Kiwi as _GuestImpl;
  pub trait Guest {
    fn intercept(ctx: Context,) -> Action;
  }
  
  #[allow(unused_imports)]
  use ::kiwi_sdk::wit_bindgen::rt::{alloc, vec::Vec, string::String};
  
  #[repr(align(4))]
  struct _RetArea([u8; 16]);
  static mut _RET_AREA: _RetArea = _RetArea([0; 16]);
  pub mod kiwi {
    pub mod kiwi {
      
      #[allow(clippy::all)]
      pub mod intercept_types {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        pub type EventPayload= Option<::kiwi_sdk::wit_bindgen::rt::vec::Vec::<u8>>;
        #[derive(Clone)]
        pub struct CounterEventCtx {
          pub source_id: ::kiwi_sdk::wit_bindgen::rt::string::String,
          pub count: u64,
        }
        impl ::core::fmt::Debug for CounterEventCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("CounterEventCtx").field("source-id", &self.source_id).field("count", &self.count).finish()
          }
        }
        #[derive(Clone)]
        pub struct KafkaEventCtx {
          pub payload: EventPayload,
          pub topic: ::kiwi_sdk::wit_bindgen::rt::string::String,
          pub timestamp: Option<u64>,
          pub partition: u32,
          pub offset: u64,
        }
        impl ::core::fmt::Debug for KafkaEventCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("KafkaEventCtx").field("payload", &self.payload).field("topic", &self.topic).field("timestamp", &self.timestamp).field("partition", &self.partition).field("offset", &self.offset).finish()
          }
        }
        #[derive(Clone)]
        pub enum EventCtx{
          Kafka(KafkaEventCtx),
          Counter(CounterEventCtx),
        }
        impl ::core::fmt::Debug for EventCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              EventCtx::Kafka(e) => {
                f.debug_tuple("EventCtx::Kafka").field(e).finish()
              }
              EventCtx::Counter(e) => {
                f.debug_tuple("EventCtx::Counter").field(e).finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub struct Websocket {
          pub addr: Option<::kiwi_sdk::wit_bindgen::rt::string::String>,
        }
        impl ::core::fmt::Debug for Websocket {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Websocket").field("addr", &self.addr).finish()
          }
        }
        #[derive(Clone)]
        pub enum ConnectionCtx{
          Websocket(Websocket),
        }
        impl ::core::fmt::Debug for ConnectionCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              ConnectionCtx::Websocket(e) => {
                f.debug_tuple("ConnectionCtx::Websocket").field(e).finish()
              }
            }
          }
        }
        /// Plugin context
        #[derive(Clone)]
        pub struct Context {
          pub auth: Option<::kiwi_sdk::wit_bindgen::rt::vec::Vec::<u8>>,
          pub connection: ConnectionCtx,
          pub event: EventCtx,
        }
        impl ::core::fmt::Debug for Context {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Context").field("auth", &self.auth).field("connection", &self.connection).field("event", &self.event).finish()
          }
        }
        #[derive(Clone)]
        pub enum Action{
          Forward,
          Discard,
          Transform(EventPayload),
        }
        impl ::core::fmt::Debug for Action {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Action::Forward => {
                f.debug_tuple("Action::Forward").finish()
              }
              Action::Discard => {
                f.debug_tuple("Action::Discard").finish()
              }
              Action::Transform(e) => {
                f.debug_tuple("Action::Transform").field(e).finish()
              }
            }
          }
        }
        
      }
      
    }
  }
  
  #[cfg(target_arch = "wasm32")]
  #[link_section = "component-type:intercept-hook"]
  #[doc(hidden)]
  pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 619] = [0, 97, 115, 109, 13, 0, 1, 0, 0, 25, 22, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 101, 110, 99, 111, 100, 105, 110, 103, 4, 0, 7, 231, 3, 1, 65, 2, 1, 65, 8, 1, 66, 20, 1, 112, 125, 1, 107, 0, 4, 0, 13, 101, 118, 101, 110, 116, 45, 112, 97, 121, 108, 111, 97, 100, 3, 0, 1, 1, 114, 2, 9, 115, 111, 117, 114, 99, 101, 45, 105, 100, 115, 5, 99, 111, 117, 110, 116, 119, 4, 0, 17, 99, 111, 117, 110, 116, 101, 114, 45, 101, 118, 101, 110, 116, 45, 99, 116, 120, 3, 0, 3, 1, 107, 119, 1, 114, 5, 7, 112, 97, 121, 108, 111, 97, 100, 2, 5, 116, 111, 112, 105, 99, 115, 9, 116, 105, 109, 101, 115, 116, 97, 109, 112, 5, 9, 112, 97, 114, 116, 105, 116, 105, 111, 110, 121, 6, 111, 102, 102, 115, 101, 116, 119, 4, 0, 15, 107, 97, 102, 107, 97, 45, 101, 118, 101, 110, 116, 45, 99, 116, 120, 3, 0, 6, 1, 113, 2, 5, 107, 97, 102, 107, 97, 1, 7, 0, 7, 99, 111, 117, 110, 116, 101, 114, 1, 4, 0, 4, 0, 9, 101, 118, 101, 110, 116, 45, 99, 116, 120, 3, 0, 8, 1, 107, 115, 1, 114, 1, 4, 97, 100, 100, 114, 10, 4, 0, 9, 119, 101, 98, 115, 111, 99, 107, 101, 116, 3, 0, 11, 1, 113, 1, 9, 119, 101, 98, 115, 111, 99, 107, 101, 116, 1, 12, 0, 4, 0, 14, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 99, 116, 120, 3, 0, 13, 1, 107, 0, 1, 114, 3, 4, 97, 117, 116, 104, 15, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 14, 5, 101, 118, 101, 110, 116, 9, 4, 0, 7, 99, 111, 110, 116, 101, 120, 116, 3, 0, 16, 1, 113, 3, 7, 102, 111, 114, 119, 97, 114, 100, 0, 0, 7, 100, 105, 115, 99, 97, 114, 100, 0, 0, 9, 116, 114, 97, 110, 115, 102, 111, 114, 109, 1, 2, 0, 4, 0, 6, 97, 99, 116, 105, 111, 110, 3, 0, 18, 3, 1, 31, 107, 105, 119, 105, 58, 107, 105, 119, 105, 47, 105, 110, 116, 101, 114, 99, 101, 112, 116, 45, 116, 121, 112, 101, 115, 64, 48, 46, 49, 46, 48, 5, 0, 2, 3, 0, 0, 7, 99, 111, 110, 116, 101, 120, 116, 3, 0, 7, 99, 111, 110, 116, 101, 120, 116, 3, 0, 1, 2, 3, 0, 0, 6, 97, 99, 116, 105, 111, 110, 3, 0, 6, 97, 99, 116, 105, 111, 110, 3, 0, 3, 1, 64, 1, 3, 99, 116, 120, 2, 0, 4, 4, 0, 9, 105, 110, 116, 101, 114, 99, 101, 112, 116, 1, 5, 4, 1, 30, 107, 105, 119, 105, 58, 107, 105, 119, 105, 47, 105, 110, 116, 101, 114, 99, 101, 112, 116, 45, 104, 111, 111, 107, 64, 48, 46, 49, 46, 48, 4, 0, 11, 20, 1, 0, 14, 105, 110, 116, 101, 114, 99, 101, 112, 116, 45, 104, 111, 111, 107, 3, 0, 0, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 50, 48, 46, 49, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48];
  
  #[inline(never)]
  #[doc(hidden)]
  #[cfg(target_arch = "wasm32")]
  pub fn __link_section() {}
  